<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>split and merge</title>
    <link href="Merge-beta.css" rel="stylesheet" type="text/css" />
    <script src="jquery/jquery-2.1.1.js"></script>
    <script type="text/javascript">
    $(window).load(function() {
        //test
        hasstorage = false;
        control = false;

        if (typeof localStorage.rectslocation !== "undefined") {
            console.log("存在！");
            hasstorage = true;
            storedrects = JSON.parse(localStorage.rectslocation);
            if (storedrects.length != 0) {
                console.log(storedrects[0].x + "  " + storedrects[0].y);
                //alert(storedrects);
            }
        }

        //画布
        back = document.getElementById("back");
        context = back.getContext("2d");
        c = document.getElementById("my");
        cxt = c.getContext("2d");
        canvaswidth = document.getElementById("my").width;
        canvasheight = document.getElementById("my").height;

        //console.log(canvaswidth+"  "+canvasheight);

        row = 10;
        column = 10;

        splitsound = document.getElementById("splitsound");
        mergesound = document.getElementById("merge");
        collisionsound = document.getElementById("collision");

        play = document.getElementById("play");
        play.addEventListener('click', playclick, false);

    });

    //玩游戏
    function playclick(event) {
        document.getElementById("menu").style.display = "none";
        document.getElementById("mode").style.display = "block";

        infinite = document.getElementById("infinite");
        infinite.addEventListener('click', playinfinite, false);
        finite = document.getElementById("finite");
        finite.addEventListener('click', playfinite, false);

        function playinfinite(event) {
            document.getElementById("content").style.display = "none";
            mode = 0;
            load();
        }

        function playfinite(event) {
            document.getElementById("content").style.display = "none";
            mode = 1;
            load();
        }
    }

    // unload application
    $(window).unload(function() {
        var rectslocation = [];
        for (var j = 0; j < rects.length; j++) {
            rectslocation[j] = {
                "x": rects[j].x,
                "y": rects[j].y,
                "color": rects[j].color,
                "number": rects[j].number
            }
        }
        if (typeof rectslocation !== "undefined") {
            localStorage.rectslocation = JSON.stringify(rectslocation);
        }
    });

    //矩形块对象数组
    var rects = [];
    //画布内格子是否填充的状态数组
    var isfill = [];
    //颜色选择数组
    var color = ["#2F4F4F", "#778899", "#8470FF", "#BDB76B", "#FFD700",
        "#CD5C5C", "#D2B48C", "#FA8072", "#FF82AB", "#5CACEE"
    ];

    //画线时保存的点的数组
    var dots_of_line = [];

    //能否画线的状态指示
    var isdrag = false;
    var linkedrects = [];

    var setinterval;
    //动画效果
    var specialrects = [];

    //模式
    var mode = -1;


    function load() {
        //每次调用时清理上次调用时残留的数组；
        clearInterval(setinterval);
        rects.length = 0;
        isfill.length = 0;

        window.addEventListener('mousedown', mousedown, false);
        window.addEventListener('mousemove', mousemove, false);
        window.addEventListener('mouseup', mouseup, false);

        //背景图
        /*var image = new Image();
        image.src = "backgroundblue.jpg";
        image.onload = function () {
            context.drawImage(image, 0, 0);
        }*/

        context.beginPath();
        context.fillStyle = "#E6E6FA";
        context.rect(0, 0, 510, 510);
        context.fill();

        generater();
        //改变画布内容
        setinterval = setInterval(draw, 1000 / 60);

    };

    function mousedown(event) {
        var position = getMousePos(event);
        var xcanvas = position.x - c.offsetLeft;
        var ycanvas = position.y - c.offsetTop;
        console.log("down!!!");
        for (var i = 0; i < rects.length; i++) {
            //检测鼠标是否在tile上
            if ((xcanvas >= rects[i].x * (canvaswidth / row) && xcanvas <= rects[i].x * (canvaswidth / row) + rects[i].width - 1) &&
                (ycanvas >= rects[i].y * (canvasheight / column) && ycanvas <= rects[i].y * (canvasheight / column) + rects[i].height - 1)) {
                //number等于0（1）时不能再分裂；
                if (rects[i].number != 0) {
                    //左边
                    if (isfill[rects[i].fillposition - 1] === false && rects[i].x != 0) {
                        //播放音效
                        splitsound.play();

                        rects[rects.length] = new rectangle(cxt, rects[i].x - 1, rects[i].y, canvaswidth / row, canvasheight / column);
                        isfill[rects[rects.length - 1].fillposition] = true;
                        if (rects[i].number === 2) {
                            rects[i].number -= 2;
                            rects[rects.length - 1].number = 1;
                        } else if (rects[i].number === 1) {
                            rects[i].number -= 1;
                            rects[rects.length - 1].number = 0;
                        }

                    }
                    //上边
                    else if (isfill[rects[i].fillposition - row] === false && rects[i].y != 0) {
                        //播放音效
                        splitsound.play();

                        rects[rects.length] = new rectangle(cxt, rects[i].x, rects[i].y - 1, canvaswidth / row, canvasheight / column);
                        isfill[rects[rects.length - 1].fillposition] = true;
                        if (rects[i].number === 2) {
                            rects[i].number -= 2;
                            rects[rects.length - 1].number = 1;
                        } else if (rects[i].number === 1) {
                            rects[i].number -= 1;
                            rects[rects.length - 1].number = 0;
                        }

                    }
                    //右边
                    else if (isfill[rects[i].fillposition + 1] === false && rects[i].x != row - 1) {
                        //播放音效
                        splitsound.play();

                        rects[rects.length] = new rectangle(cxt, rects[i].x + 1, rects[i].y, canvaswidth / row, canvasheight / column);
                        isfill[rects[rects.length - 1].fillposition] = true;
                        if (rects[i].number === 2) {
                            rects[i].number -= 2;
                            rects[rects.length - 1].number = 1;
                        } else if (rects[i].number === 1) {
                            rects[i].number -= 1;
                            rects[rects.length - 1].number = 0;
                        }

                    }
                    //下边
                    else if (isfill[rects[i].fillposition + row] === false && rects[i].y != column - 1) {

                        //播放音效
                        splitsound.play();

                        rects[rects.length] = new rectangle(cxt, rects[i].x, rects[i].y + 1, canvaswidth / row, canvasheight / column);
                        isfill[rects[rects.length - 1].fillposition] = true;
                        if (rects[i].number === 2) {
                            rects[i].number -= 2;
                            rects[rects.length - 1].number = 1;
                        } else if (rects[i].number === 1) {
                            rects[i].number -= 1;
                            rects[rects.length - 1].number = 0;
                        }

                    }
                    //不能移动
                    else {
                        alert("No Space!Please link the tiles of the same color  to merge them.");
                        console.log("No Space!Please link the tiles of the same color  to merge them.")
                    }
                }
                //不可分裂的情况
                else {
                    //alert("Please link the tiles of the same color  to merge them.");
                    dots_of_line[0] = new Point2D(xcanvas, ycanvas);
                    isdrag = true;
                    linkedrects[0] = rects[i];
                    console.log("cao");
                }
            }
        }

        handlecrossbound(xcanvas, ycanvas);
    }

    //记录线段的点
    var bigger = 0;
    //已被画线所连接的矩形块增量
    var keeplinked = 0;

    function mousemove(event) {
        var position = getMousePos(event);
        var xcanvas = position.x - c.offsetLeft;
        var ycanvas = position.y - c.offsetTop;
        if (isdrag) {
            bigger += 1;
            for (var i = 0; i < rects.length; i++) {
                if ((xcanvas >= rects[i].x * (canvaswidth / row) && xcanvas <= rects[i].x * (canvaswidth / row) + rects[i].width + 2) &&
                    (ycanvas >= rects[i].y * (canvasheight / column) && ycanvas <= rects[i].y * (canvasheight / column) + rects[i].height + 2)) {
                    //number等于0（1）时不能再分裂；
                    if (rects[i].number != 0) {
                        isdrag = false;
                        break;
                    } else {
                        keeplinked += 1;
                        linkedrects[keeplinked] = rects[i];
                        if (linkedrects[keeplinked - 1].color != linkedrects[keeplinked].color) {
                            isdrag = false;
                            break;
                        }
                        if (linkedrects[keeplinked - 1].number != linkedrects[keeplinked].number) {
                            isdrag = false;
                            break;
                        }
                    }
                    //不要改下面的括号
                }
            }

            dots_of_line[bigger] = new Point2D(xcanvas, ycanvas);

        }

        handlecrossbound(xcanvas, ycanvas);
    }

    function mouseup(event) {
        var position = getMousePos(event);
        var xcanvas = position.x - c.offsetLeft;
        var ycanvas = position.y - c.offsetTop;

        isdrag = false; //左键状态标识为松开
        var hasbeenlinked = [];
        var inindex = -1;
        var last = -1;
        var current = -1;
        var temp = 0;

        for (var sh = 0; sh < dots_of_line.length; sh++) {
            for (var i = 0; i < rects.length; i++) {
                if ((dots_of_line[sh].x >= rects[i].x * (canvaswidth / row) && dots_of_line[sh].x <= rects[i].x * (canvaswidth / row) + rects[i].width + 2) &&
                    (dots_of_line[sh].y >= rects[i].y * (canvasheight / column) && dots_of_line[sh].y <= rects[i].y * (canvasheight / column) + rects[i].height + 2)) {

                    // if(hasbeenlinked.length>=1){
                    current = i;
                    temp = 0;
                    if (last === current) {
                        last = current;
                    } else {
                        last = current;
                        for (var tem = 0; tem < hasbeenlinked.length; tem++) {
                            if (hasbeenlinked[tem] != i) {
                                temp += 1;
                            }
                        }
                        if (temp === hasbeenlinked.length) {
                            inindex += 1;
                            hasbeenlinked[inindex] = i;
                            console.log("+1");
                        }
                    }
                    // }else if(hasbeenlinked.length===0){
                    //inindex+=1;
                    //hasbeenlinked[inindex]=i;
                    //last=i;
                    //console.log("first");
                    //}
                }
            }
        }

        for (var te = 0; te < hasbeenlinked.length; te++) {
            console.log(hasbeenlinked[te]);
        }

        if (hasbeenlinked.length === 2) {
            if (rects[hasbeenlinked[0]].color === rects[hasbeenlinked[1]].color) {
                if (rects[hasbeenlinked[0]].number === rects[hasbeenlinked[1]].number) {
                    console.log("颜色相同！");

                    //动画效果
                    specialrects[0] = rects[hasbeenlinked[0]];
                    specialrects[1] = rects[hasbeenlinked[1]];


                    isfill[rects[hasbeenlinked[0]].fillposition] = false;
                    rects.splice(hasbeenlinked[0], 1);

                    if (hasbeenlinked[0] < hasbeenlinked[1]) {
                        isfill[rects[hasbeenlinked[1] - 1].fillposition] = false;
                        rects.splice(hasbeenlinked[1] - 1, 1);
                    } else {
                        isfill[rects[hasbeenlinked[1]].fillposition] = false;
                        rects.splice(hasbeenlinked[1], 1);
                    }

                    //播放音效
                    mergesound.play();

                    //无限模式下消除两个矩形块时在空位置上随机生成一个矩形块
                    if (mode === 0) {
                        var gameover2 = 0;
                        for (var over9 = 0; over9 < isfill.length; over9++) {
                            if (isfill[over9] === false) {
                                gameover2 += 1;
                            }
                        }
                        if (gameover2 > 0) {
                            rects[rects.length] = new rectangle(cxt, getRandom(row), getRandom(column), canvaswidth / row, canvasheight / column);

                            //调用get_empty_position函数；
                            get_empty_position(rects[rects.length - 1]);
                            isfill[rects[rects.length - 1].fillposition] = true;
                        }
                    }

                } else {
                    console.log("颜色和数字不同不能消除！");
                }


                //
            } else {
                //播放音效
                collisionsound.play();
            }
        } else if (hasbeenlinked.length > 2 && hasbeenlinked.length <= 3) {
            if ((rects[hasbeenlinked[0]].color === rects[hasbeenlinked[1]].color) && (rects[hasbeenlinked[2]].color === rects[hasbeenlinked[1]].color)) {
                if ((rects[hasbeenlinked[0]].number === rects[hasbeenlinked[1]].number) && rects[hasbeenlinked[2]].number === 0) {
                    console.log("颜色相同哎！");

                    //动画效果
                    specialrects[0] = rects[hasbeenlinked[0]];
                    specialrects[1] = rects[hasbeenlinked[1]];
                    specialrects[2] = rects[hasbeenlinked[2]];

                    for (var ee = 0; ee < hasbeenlinked.length; ee++) {
                        if (ee === 0) {
                            isfill[rects[hasbeenlinked[ee]].fillposition] = false;
                            rects.splice(hasbeenlinked[ee], 1);
                            //console.log("caoao");
                        }
                        if (ee === 1) {
                            if (hasbeenlinked[ee - 1] < hasbeenlinked[ee]) {
                                isfill[rects[hasbeenlinked[ee] - 1].fillposition] = false;
                                rects.splice(hasbeenlinked[ee] - 1, 1);
                            } else {
                                isfill[rects[hasbeenlinked[ee]].fillposition] = false;
                                rects.splice(hasbeenlinked[ee], 1);
                            }

                        }

                        if (ee === 2) {
                            if (hasbeenlinked[ee - 2] < hasbeenlinked[ee] && hasbeenlinked[ee - 1] < hasbeenlinked[ee]) {
                                isfill[rects[hasbeenlinked[ee] - 2].fillposition] = false;
                                rects.splice(hasbeenlinked[ee] - 2, 1);
                            } else if ((hasbeenlinked[ee - 2] < hasbeenlinked[ee] && hasbeenlinked[ee - 1] > hasbeenlinked[ee]) ||
                                (hasbeenlinked[ee - 2] > hasbeenlinked[ee] && hasbeenlinked[ee - 1] < hasbeenlinked[ee])) {
                                isfill[rects[hasbeenlinked[ee] - 1].fillposition] = false;
                                rects.splice(hasbeenlinked[ee] - 1, 1);
                            } else if (hasbeenlinked[ee - 2] > hasbeenlinked[ee] && hasbeenlinked[ee - 1] > hasbeenlinked[ee]) {
                                isfill[rects[hasbeenlinked[ee]].fillposition] = false;
                                rects.splice(hasbeenlinked[ee], 1);
                            }
                        }

                        //
                    }

                    //播放音效
                    mergesound.play();

                    //无限模式下消除三个矩形块时在空位置上随机生成两个矩形块
                    if (mode === 0) {
                        var gameover4 = 0;
                        for (var overl = 0; overl < isfill.length; overl++) {
                            if (isfill[overl] === false) {
                                gameover4 += 1;
                            }
                        }
                        if (gameover4 > 1) {
                            for (var two = 0; two < 2; two++) {
                                rects[rects.length] = new rectangle(cxt, getRandom(row), getRandom(column), canvaswidth / row, canvasheight / column);
                                //调用get_empty_position函数；
                                get_empty_position(rects[rects.length - 1]);
                                isfill[rects[rects.length - 1].fillposition] = true;
                                var testss = two + 1;
                                console.log(testss);
                            }
                        }
                        if (gameover4 > 0 && gameover4 < 2) {
                            rects[rects.length] = new rectangle(cxt, getRandom(row), getRandom(column), canvaswidth / row, canvasheight / column);
                            //调用get_empty_position函数；
                            get_empty_position(rects[rects.length - 1]);
                            isfill[rects[rects.length - 1].fillposition] = true;
                        }
                    }

                }
            } else {
                //播放音效
                collisionsound.play();
                console.log("数字或颜色不一样哦！")
            };

        } else if (hasbeenlinked.length >= 4) {
            //播放音效
            collisionsound.play();
            console.log("最多只能连三个！");
        }



        var close = true;
        var xx = -1;
        var yy = -1;
        var jyy = 0;
        var hyy = 0;
        var jyyy = 0;
        var lengthzero = 0;
        //game over 1
        for (var over10 = 0; over10 < rects.length; over10++) {
            if (rects[over10].number !== 0) {
                if (isfill[rects[over10].fillposition - 1] === false && rects[over10].x != 0) {
                    close = false;
                    break;
                }
                if (isfill[rects[over10].fillposition - row] === false && rects[over10].y != 0) {
                    close = false;
                    break;
                }
                if (isfill[rects[over10].fillposition + row] === false && rects[over10].y != column - 1) {
                    close = false;
                    break;
                }
                if (isfill[rects[over10].fillposition + 1] === false && rects[over10].x != row - 1) {
                    close = false;
                    break;
                }
            }
        }
        console.log(close);
        if (close === true) {
            for (var over9 = 0; over9 < rects.length; over9++) {
                if (rects[over9].number === 0) {
                    lengthzero += 1;
                    //左面
                    if (rects[over9].x !== 0) {
                        if (isfill[rects[over9].fillposition - 1] === true) {
                            xx = rects[over9].x - 1;
                            yy = rects[over9].y;

                            for (var over11 = 0; over11 < rects.length; over11++) {
                                if (rects[over11].x === xx && rects[over11].y === yy) {
                                    jyy += 1;
                                    if (rects[over11].number === 0) {
                                        if (rects[over11].color !== rects[over9].color) {
                                            hyy += 1;

                                        }
                                    } else {
                                        hyy += 1;
                                    }
                                }
                            }
                        }
                    }
                    //上面
                    if (rects[over9].y !== 0) {
                        if (isfill[rects[over9].fillposition - row] === true) {
                            xx = rects[over9].x;
                            yy = rects[over9].y - 1;

                            for (var over12 = 0; over12 < rects.length; over12++) {
                                if (rects[over12].x === xx && rects[over12].y === yy) {
                                    jyy += 1;
                                    if (rects[over12].number === 0) {
                                        if (rects[over12].color !== rects[over9].color) {

                                            hyy += 1;
                                        }
                                    } else {
                                        hyy += 1;
                                    }
                                }
                            }
                        }
                    }
                    //下面
                    if (rects[over9].y !== column - 1) {
                        if (isfill[rects[over9].fillposition + row] === true) {
                            xx = rects[over9].x;
                            yy = rects[over9].y + 1;

                            for (var over13 = 0; over13 < rects.length; over13++) {
                                if (rects[over13].x === xx && rects[over13].y === yy) {
                                    jyy += 1;
                                    if (rects[over13].number === 0) {
                                        if (rects[over13].color !== rects[over9].color) {
                                            hyy += 1;

                                        }
                                    } else {
                                        hyy += 1;
                                    }
                                }
                            }
                        }
                    }
                    //右边
                    if (rects[over9].x !== row - 1) {
                        if (isfill[rects[over9].fillposition + 1] === true) {
                            xx = rects[over9].x + 1;
                            yy = rects[over9].y;

                            for (var over14 = 0; over14 < rects.length; over14++) {
                                if (rects[over14].x === xx && rects[over14].y === yy) {
                                    jyy += 1;
                                    if (rects[over14].number === 0) {
                                        if (rects[over14].color !== rects[over9].color) {
                                            hyy += 1;
                                        }
                                    } else {
                                        hyy += 1;
                                    }
                                }
                            }
                        }
                    }

                    console.log("jyy: " + jyy);
                    console.log("hyy: " + hyy);
                    if (jyy === hyy) {
                        jyyy += 1;
                    }
                    jyy = 0;
                    hyy = 0;
                }
            }
            console.log("jyyy: " + jyyy);
            console.log("length: " + lengthzero);
            if (jyyy === lengthzero) {
                console.log("no same color!!");
                //检查是否游戏结束
                var isover = true;
                var hasemptyneib = 0;
                for (var over15 = 0; over15 < rects.length; over15++) {
                    if (rects[over15].number === 0) {
                        //左面
                        if (rects[over15].x !== 0) {
                            if (isfill[rects[over15].fillposition - 1] === false) {
                                hasemptyneib += 1;
                            }
                        }
                        //上面
                        if (rects[over15].y !== 0) {
                            if (isfill[rects[over15].fillposition - row] === false) {
                                hasemptyneib += 1;
                            }
                        }
                        //下面
                        if (rects[over15].y !== column - 1) {
                            if (isfill[rects[over15].fillposition + row] === false) {
                                hasemptyneib += 1;
                            }
                        }
                        //右边
                        if (rects[over15].x !== row - 1) {
                            if (isfill[rects[over15].fillposition + 1] === false) {
                                hasemptyneib += 1;
                            }
                        }

                        //应用寻找相同色块函数
                        if (hasemptyneib > 0) {
                            hasemptyneib = 0;
                            console.log("has empty isfill");
                            isover = samecolorblock(rects[over15], rects[over15].fillposition);
                            if (isover === false) {
                                break;
                            }
                        }
                    }
                }
                //检查是否游戏结束
                if (isover) {
                    console.log("game over!!!");
                    console.log("game over!");
                    document.getElementById("content").style.display = "block";
                    document.getElementById("gameinfo").style.fontSize = "40px";
                    document.getElementById("gameinfo").style.color = "#ff00ff";
                    document.getElementById("gameinfo").innerText = "GAME OVER!";
                }

            }
        }












        /*var  compare=0;
		 var  gameover=0;
		 var  win=0;
		 for(var over1=0;over1<rects.length;over1++){
		         if(rects[over1].number===0){
				       gameover+=1;
			     }
		 }
		 
		 
		 if(gameover===rects.length){
		           for(var over2=0;over2<rects.length;over2++){
				              for(var over3=0;over3<rects.length;over3++){
							            if(rects[over2].color!==rects[over3].color){
										         compare+=1;
												 
										}
						      }
							 console.log(compare);
							 console.log(rects.length-1);
							if(compare===rects.length-1){
							        console.log("game over!");
									document.getElementById("menu").style.display="block";
									document.getElementById("gameinfo").style.fontSize="40px";
									document.getElementById("gameinfo").style.color="#ff00ff";
									document.getElementById("gameinfo").innerText="GAME OVER!";
									animation=0;
									specialrects.length=0;
							       break;
							}
							compare=0;
							   
				   }
		 }
		
		 for(var winwin=0;winwin<isfill.length;winwin++){
		         if(isfill[winwin]===false){
				           win+=1;
                 }				 
		  }
		 if(win===isfill.length){
		           document.getElementById("menu").style.display="block";
				   document.getElementById("gameinfo").style.fontSize="40px";
				   document.getElementById("gameinfo").style.color="#ff00ff";
		           document.getElementById("gameinfo").innerText="you win!";
				   console.log("YOU WIN!");
		}*/



        //重新初始化连线坐标数组
        dots_of_line.length = 0;
        bigger = 0;
        keeplinked = 0;
        linkedrects.length = 0;

        handlecrossbound(xcanvas, ycanvas);
    }

    //队列寻找相同色块函数
    //传进初始rect，初始rect的isfill下标值
    function samecolorblock(thatrect, isfillindex) {
        var queue = [];
        var visited = [];
        var hasvisited = false;
        var isgameover = true;
        queue.push(isfillindex);
        visited.push(isfillindex);
        console.log("function is called");
        while (queue.length !== 0) {
            console.log("here!!!!");
            var len = queue.length;
            for (var hju = 0; hju < len; hju++) {
                var node = queue.shift();
                console.log("hereraa");

                if (node === isfillindex) {
                    console.log("isfillllllll")
                    console.log(node);

                    if (node % 10 != 9 && !isfill[node + 1]) {
                        console.log("firstempty");
                        console.log(isfill[node + 1]);
                        for (var lla = 0; lla < visited.length; lla++) {
                            if (node + 1 === visited[lla]) {
                                hasvisited = true;
                            }
                        }
                        if (hasvisited === false) {
                            queue.push(node + 1);
                            visited.push(node + 1);
                            console.log("nodenodefirst");
                        }
                        hasvisited = false;
                    }

                    if (node % 10 != 0 && !isfill[node - 1]) {
                        console.log("firstempty");
                        console.log(isfill[node - 1]);
                        for (var lla1 = 0; lla1 < visited.length; lla1++) {
                            if (node - 1 === visited[lla1]) {
                                hasvisited = true;
                            }
                        }
                        if (hasvisited === false) {
                            queue.push(node - 1);
                            visited.push(node - 1);
                            console.log("nodenodefirst");
                        }
                        hasvisited = false;
                    }

                    if (node < (row * column) - 10 && !isfill[node + row]) {
                        console.log("firstempty");
                        console.log(isfill[node + row]);
                        for (var lla2 = 0; lla2 < visited.length; lla2++) {
                            if (node + row === visited[lla2]) {
                                hasvisited = true;

                            }
                        }
                        if (hasvisited === false) {
                            queue.push(node + row);
                            visited.push(node + row);
                            console.log("nodenodefirst");
                        }
                        hasvisited = false;
                    }

                    if (node > column - 1 && !isfill[node - row]) {
                        console.log("firstempty");
                        console.log(isfill[node - row]);
                        for (var lla3 = 0; lla3 < visited.length; lla3++) {
                            if (node - row === visited[lla3]) {
                                hasvisited = true;
                            }
                        }
                        if (hasvisited === false) {
                            queue.push(node - row);
                            visited.push(node - row);
                            console.log("nodenodefirst");
                        }
                        hasvisited = false;
                    }
                } else if (isfill[node] === false) {
                    if (node % 10 != 9) {
                        for (var lla4 = 0; lla4 < visited.length; lla4++) {
                            if (node + 1 === visited[lla4]) {
                                hasvisited = true;
                            }
                        }
                        if (hasvisited === false) {
                            queue.push(node + 1);
                            visited.push(node + 1);
                            console.log("nodenodetwo");
                        }
                        hasvisited = false;
                    }

                    if (node % 10 != 0) {
                        for (var lla5 = 0; lla5 < visited.length; lla5++) {
                            if (node - 1 === visited[lla5]) {
                                hasvisited = true;
                            }
                        }
                        if (hasvisited === false) {
                            queue.push(node - 1);
                            visited.push(node - 1);
                            console.log("nodenodetwo");
                        }
                        hasvisited = false;
                    }

                    if (node < (row * column) - 10) {
                        for (var lla6 = 0; lla6 < visited.length; lla6++) {
                            if (node + row === visited[lla6]) {
                                hasvisited = true;
                            }
                        }
                        if (hasvisited === false) {
                            queue.push(node + row);
                            visited.push(node + row);
                            console.log("nodenodetwo");
                        }
                        hasvisited = false;
                    }

                    if (node > column - 1) {
                        for (var lla7 = 0; lla7 < visited.length; lla7++) {
                            if (node - row === visited[lla7]) {
                                hasvisited = true;
                            }
                        }
                        if (hasvisited === false) {
                            queue.push(node - row);
                            visited.push(node - row);
                            console.log("nodenodetwo");
                        }
                        hasvisited = false;
                    }


                } else if (isfill[node] === true && node !== isfillindex) {
                    var xxx = node % row;
                    var yyy = Math.floor(node / row);
                    console.log("elseelse");
                    console.log(xxx);
                    console.log(yyy);
                    for (var xyz = 0; xyz < rects.length; xyz++) {
                        if (xxx === rects[xyz].x && yyy === rects[xyz].y) {
                            console.log("match");
                            console.log(rects[xyz].color);
                            console.log(thatrect.color);
                            if (rects[xyz].color === thatrect.color) {
                                isgameover = false;
                                console.log("has same color blocks");
                                queue.length = 0;
                                break;
                            }
                        }
                    }
                    //											 
                }
                //for
            }

            //while				 
        }
        return isgameover;
    }


    //边界碰撞检测函数
    function handlecrossbound(xcanvas, ycanvas) {

        if (xcanvas <= 0 || xcanvas >= canvaswidth - 1) {
            isdrag = false;
            return;
        } else if (ycanvas <= 0 || ycanvas >= canvasheight - 1) {
            isdrag = false;
            return;
        }
    }

    var animation = 0;

    //画布重绘rects和连线（数组）；
    function draw() {

        cxt.clearRect(0, 0, canvaswidth, canvasheight, 0.2);

        for (var i = 0; i < rects.length; i++) {
            rects[i].drawitself();
        }

        //动画效果
        if (specialrects.length > 0) {
            animation += 1;
            //console.log(animation);
            for (var an = 0; an < specialrects.length; an++) {
                cxt.beginPath();
                cxt.fillStyle = specialrects[an].color;
                cxt.rect(specialrects[an].x * (canvaswidth / row) + animation, specialrects[an].y * (canvasheight / column) + animation, specialrects[an].width - 3 - 2 * animation, specialrects[an].height - 3 - 2 * animation);
                cxt.fill();
                //console.log("caoaoaavfaga");
            }
            if (animation >= (canvaswidth / row - 3) / 2) {
                animation = 0;
                specialrects.length = 0;
            }
        }



        if (dots_of_line.length > 0) {
            if (isdrag) {
                for (var m = 0; m < dots_of_line.length - 1; m++) {
                    cxt.beginPath();
                    cxt.lineWidth = 6;
                    cxt.strokeStyle = "#ffffff"
                        //设置线条接头处为圆滑的
                    cxt.lineCap = cxt.lineJoin = "round";
                    cxt.moveTo(dots_of_line[m].x, dots_of_line[m].y);
                    cxt.lineTo(dots_of_line[m + 1].x, dots_of_line[m + 1].y);
                    cxt.stroke();
                }
            } else {
                for (var n = 0; n < dots_of_line.length - 1; n++) {
                    cxt.beginPath();
                    cxt.lineWidth = 6;
                    cxt.strokeStyle = "#ff00ff";
                    //设置线条接头处为圆滑的
                    cxt.lineCap = cxt.lineJoin = "round";
                    cxt.moveTo(dots_of_line[n].x, dots_of_line[n].y);
                    cxt.lineTo(dots_of_line[n + 1].x, dots_of_line[n + 1].y);
                    cxt.stroke();
                }

            }
        }
    };




    //rects初始化；
    function generater() {

        for (var k = 0; k < row * column; k++) {
            isfill[k] = false;
        }
        if (hasstorage === true && control === true) {
            for (var i = 0; i < storedrects.length; i++) {
                rects[i] = new rectangle(cxt, storedrects[i].x, storedrects[i].y, canvaswidth / row, canvasheight / column);
                console.log(rects[0].x + "  " + rects[0].y);
                isfill[rects[i].fillposition] = true;
                rects[i].number = storedrects[i].number;
                rects[i].color = storedrects[i].color;
                //调用get_empty_position函数；
                //get_empty_position(rects[i]);
                console.log(isfill[rects[i].fillposition] + "   hhah");
            }
        } else {
            if (mode === 0) {
                for (var i = 0; i < 15; i++) {
                    rects[i] = new rectangle(cxt, getRandom(row), getRandom(column), canvaswidth / row, canvasheight / column);
                    rects[i].number = 2;
                    //调用get_empty_position函数；
                    get_empty_position(rects[i]);
                    console.log(isfill[rects[i].fillposition]);
                }
            } else {
                for (var i = 0; i < 45; i++) {
                    rects[i] = new rectangle(cxt, getRandom(row), getRandom(column), canvaswidth / row, canvasheight / column);
                    rects[i].number = 2;
                    //调用get_empty_position函数；
                    get_empty_position(rects[i]);
                    console.log(isfill[rects[i].fillposition]);
                }
            }
        }

    }

    //递归获得空位来放置titile；
    function get_empty_position(rect_angle) {
        if (isfill[rect_angle.fillposition] === false) {
            //console.log("done");
            isfill[rect_angle.fillposition] = true;
        } else {
            //console.log("recursion");
            rect_angle.x = getRandom(row);
            rect_angle.y = getRandom(column);
            rect_angle.fillposition = rect_angle.x + rect_angle.y * row;
            get_empty_position(rect_angle);
        }
    }

    //title对象
    function rectangle(cxt, x, y, width, height) {
        this.cxt = cxt;
        this.x = x;
        this.y = y;
        this.fillposition = this.x + this.y * row;
        this.width = width;
        this.height = height;
        this.number = getRandom(3);
        this.color = color[getRandom(9)];
        rectangle.prototype.drawitself = function() {
            this.cxt.beginPath();
            this.cxt.fillStyle = this.color;
            // this.cxt.strokeStyle = "#000000"
            //this.cxt.lineWidth = 1;
            this.cxt.rect(this.x * (canvaswidth / row), this.y * (canvasheight / column), this.width - 3, this.height - 3);
            this.cxt.fill();
            //this.cxt.stroke();

            if (this.number != 0) {
                this.cxt.beginPath();
                this.cxt.fillStyle = "#FFFFFF";
                this.cxt.font = '30px Segoe UI bold';
                this.cxt.textBaseline = 'top';
                this.cxt.fillText(this.number + 1, this.x * (canvaswidth / row) + 15, this.y * (canvasheight / column) + 5);
            }
        }
    }

    //点对象
    function Point2D(x, y) {
        this.x = x || 0.0;
        this.y = y || 0.0;
    }

    //功能函数
    function getRandom(n) {
        return Math.floor(Math.random() * n);
    }

    function getMousePos(event) {
        var e = event || window.event;
        var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
        var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
        var x = e.pageX || e.clientX + scrollX;
        var y = e.pageY || e.clientY + scrollY;
        //alert('x: ' + x + '\ny: ' + y);
        return {
            'x': x,
            'y': y
        };
    }
    </script>
</head>

<body>
    <audio id="splitsound" src="click.wav" preload="auto">
    </audio>
    <audio id="merge" src="merge.mp3" preload="auto">
    </audio>
    <audio id="collision" src="collision.wav" preload="auto">
    </audio>
    <canvas id="back" width="510" height="510">
        Your browser does not support the canvas element.
    </canvas>
    <canvas id="my" width="500" height="500">
        Your browser does not support the canvas element.
    </canvas>
    <div id="content">
        <div id="menu">
            <button id="play">Start</button>
            <div id="gameinfo"> <span></span></div>
        </div>
        <div id="mode">
            <button id="infinite">Infinite</button>
            <button id="finite">Finite</button>
        </div>
    </div>
</body>

</html>
